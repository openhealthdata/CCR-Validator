/*
 * Copyright 2011 OpenHealthData, Inc.
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Affero General Public License as
 * published by the Free Software Foundation, either version 3 of the
 * License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Affero General Public License for more details.

 * You should have received a copy of the GNU Affero General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */
package org.openhealthdata.validator.tree;

import java.lang.reflect.Field;
import java.lang.reflect.Method;
import java.util.ArrayList;
import java.util.Collection;
import java.util.HashMap;
import java.util.Map;

import javax.xml.bind.annotation.*;

/**
 * Provides a simple reflection service to obtain methods for accessing
 * the JavaBean properties of a JAXB generated class. Code in this class
 * assumes that the reflected class has been generated by JAXB and some
 * fundamental annotations are present.
 * 
 * Notice that this would have to be modified in order to work with
 * hand-coded classes with only minimal or no JAXB annotations.
 *  
 * @author wlaun
 *
 */
public class Reflector {

    /**
     * Represents a getter method and associated data.
     * @author wlaun
     *
     */
    public class Entry {
        private String property;
        private Method method;
        private String nodeName;
        
        /**
         * Constructor, accepting all data.
         * @param property the property name
         * @param method the getter method
         * @param nodeName the XML node name
         */
        Entry( String property, Method method, String nodeName ){
            this.property = property;
            this.method   = method;
            this.nodeName = nodeName;
        }

        /**
         * Returns the property name.
         * @return a String
         */
        public String getProperty() {
            return property;
        }

        /**
         * Returns the getter method. 
         * @return a Method object
         */
        public Method getMethod() {
            return method;
        }

        /**
         * Returns the XML node name.
         * @return
         */
        public String getNodeName() {
            return nodeName;
        }
    }
    
    private Map<Class<?>,Collection<Entry>> class2methods;
    
    /**
     * Constructor.
     */
    public Reflector(){
        class2methods = new HashMap<Class<?>,Collection<Entry>>();
    }
    
    /**
     * Obtain all entries defining the methods for accessing all
     * properties of the JavaBean. Methods are returned in an order 
     * agreeing with the underlying XML schema.
     * @param clazz the JavaBean class 
     * @return a Collection of Entry objects
     */
    public Collection<Entry> getMethods( Class<?> clazz ){
        Collection<Entry> methods = class2methods.get( clazz );
        if( methods != null ){
            return methods;
        }
        methods = findEntries( clazz );
        class2methods.put( clazz, methods );
        return methods;
    }
    
    private String[] getProperties( Class<?> clazz ){
        XmlType xmlType = clazz.getAnnotation( XmlType.class );
        if( xmlType != null ) return xmlType.propOrder();
        
        // Fallback: access fields
        throw new IllegalStateException( "no propOrder on class " + clazz.getName() );
    }
    
    private Method methodForProperty( Class<?> clazz, String property ){
        String mName = "get" + property.substring(0, 1).toUpperCase() + property.substring( 1 );
        Method method;
        try {
            method = clazz.getDeclaredMethod( mName );
            if( method != null ) return method;
        } catch (Exception e) {
        }
        mName = "is" + property.substring(0, 1).toUpperCase() + property.substring( 1 );
        try {
            method = clazz.getDeclaredMethod( mName );
            if( method != null ) return method;
        } catch (Exception e) {
            e.printStackTrace();
        }
        throw new IllegalStateException( "cannot find method for " + property );
    }
    
    private Field fieldForProperty( Class<?> clazz, String property ){
        Field field;
        try {
            field = clazz.getDeclaredField( property );
            if( field != null ) return field;
        } catch ( Exception e ) {
            e.printStackTrace();       
        }
        throw new IllegalStateException( "cannot fiend field for " + property );
    }
    
    private String nodeNameForField( Field field ){
        XmlElement xmlElement = field.getAnnotation( XmlElement.class );
        if( xmlElement != null ){
            String nodeName = xmlElement.name();
            if( nodeName == null ) nodeName = field.getName();
            return nodeName;
        } else {
            // No XmlElement annotation - use the field name.
            return field.getName();
        }
    }
    
    private Collection<Entry> entriesForProperties( Class<?> clazz, String[] properties ){
        Collection<Entry> methods = new ArrayList<Entry>( properties.length );
        for( String property: properties ){
            Field field = fieldForProperty( clazz, property );
            String nodeName = nodeNameForField( field );
            Method method = methodForProperty( clazz, nodeName );
            methods.add( new Entry( property, method, nodeName ) );
        }
        return methods;
    }
    
    private Collection<Entry> findEntries( Class<?> clazz ){
        // obtain @XmlType.propOrder: the properties
        String[] properties = getProperties( clazz );
        Collection<Entry> entries = entriesForProperties( clazz, properties );
        Class<?> superclass = clazz.getSuperclass();
        Collection<Entry> allEntries;
        if( superclass.equals( Object.class ) ){
            allEntries = new ArrayList<Entry>();
        } else {
            allEntries = findEntries( superclass );
        }
        allEntries.addAll( entries );
        return allEntries;
    }
}
